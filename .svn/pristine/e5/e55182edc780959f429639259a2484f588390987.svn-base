{"remainingRequest":"D:\\iview-admin-master\\node_modules\\thread-loader\\dist\\cjs.js!D:\\iview-admin-master\\node_modules\\babel-loader\\lib\\index.js!D:\\iview-admin-master\\node_modules\\eslint-loader\\index.js??ref--13-0!D:\\iview-admin-master\\src\\libs\\security.js","dependencies":[{"path":"D:\\iview-admin-master\\src\\libs\\security.js","mtime":1560827813667},{"path":"D:\\iview-admin-master\\.babelrc","mtime":1560231513000},{"path":"D:\\iview-admin-master\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\iview-admin-master\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\iview-admin-master\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\iview-admin-master\\node_modules\\eslint-loader\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.number.constructor\";\n\n/*\n * RSA, a suite of routines for performing RSA public-key computations in JavaScript.\n * Copyright 1998-2005 David Shapiro.\n * Dave Shapiro\n * dave@ohdave.com \n * changed by Fuchun, 2010-05-06\n * fcrpg2005@gmail.com\n */\nvar RSAUtils = function ($w) {\n  if (typeof $w.RSAUtils === 'undefined') var RSAUtils = $w.RSAUtils = {};\n  var biRadixBase = 2;\n  var biRadixBits = 16;\n  var bitsPerDigit = biRadixBits;\n  var biRadix = 1 << 16; // = 2^16 = 65536\n\n  var biHalfRadix = biRadix >>> 1;\n  var biRadixSquared = biRadix * biRadix;\n  var maxDigitVal = biRadix - 1;\n  var maxInteger = 9999999999999998; //maxDigits:\n  //Change this to accommodate your largest number size. Use setMaxDigits()\n  //to change it!\n  //\n  //In general, if you're working with numbers of size N bits, you'll need 2*N\n  //bits of storage. Each digit holds 16 bits. So, a 1024-bit key will need\n  //\n  //1024 * 2 / 16 = 128 digits of storage.\n  //\n\n  var maxDigits;\n  var ZERO_ARRAY;\n  var bigZero, bigOne;\n\n  var BigInt = $w.BigInt = function (flag) {\n    if (typeof flag == \"boolean\" && flag == true) {\n      this.digits = null;\n    } else {\n      this.digits = ZERO_ARRAY.slice(0);\n    }\n\n    this.isNeg = false;\n  };\n\n  RSAUtils.setMaxDigits = function (value) {\n    maxDigits = value;\n    ZERO_ARRAY = new Array(maxDigits);\n\n    for (var iza = 0; iza < ZERO_ARRAY.length; iza++) {\n      ZERO_ARRAY[iza] = 0;\n    }\n\n    bigZero = new BigInt();\n    bigOne = new BigInt();\n    bigOne.digits[0] = 1;\n  };\n\n  RSAUtils.setMaxDigits(20); //The maximum number of digits in base 10 you can convert to an\n  //integer without JavaScript throwing up on you.\n\n  var dpl10 = 15;\n\n  RSAUtils.biFromNumber = function (i) {\n    var result = new BigInt();\n    result.isNeg = i < 0;\n    i = Math.abs(i);\n    var j = 0;\n\n    while (i > 0) {\n      result.digits[j++] = i & maxDigitVal;\n      i = Math.floor(i / biRadix);\n    }\n\n    return result;\n  }; //lr10 = 10 ^ dpl10\n\n\n  var lr10 = RSAUtils.biFromNumber(1000000000000000);\n\n  RSAUtils.biFromDecimal = function (s) {\n    var isNeg = s.charAt(0) == '-';\n    var i = isNeg ? 1 : 0;\n    var result; // Skip leading zeros.\n\n    while (i < s.length && s.charAt(i) == '0') {\n      ++i;\n    }\n\n    if (i == s.length) {\n      result = new BigInt();\n    } else {\n      var digitCount = s.length - i;\n      var fgl = digitCount % dpl10;\n      if (fgl == 0) fgl = dpl10;\n      result = RSAUtils.biFromNumber(Number(s.substr(i, fgl)));\n      i += fgl;\n\n      while (i < s.length) {\n        result = RSAUtils.biAdd(RSAUtils.biMultiply(result, lr10), RSAUtils.biFromNumber(Number(s.substr(i, dpl10))));\n        i += dpl10;\n      }\n\n      result.isNeg = isNeg;\n    }\n\n    return result;\n  };\n\n  RSAUtils.biCopy = function (bi) {\n    var result = new BigInt(true);\n    result.digits = bi.digits.slice(0);\n    result.isNeg = bi.isNeg;\n    return result;\n  };\n\n  RSAUtils.reverseStr = function (s) {\n    var result = \"\";\n\n    for (var i = s.length - 1; i > -1; --i) {\n      result += s.charAt(i);\n    }\n\n    return result;\n  };\n\n  var hexatrigesimalToChar = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\n  RSAUtils.biToString = function (x, radix) {\n    // 2 <= radix <= 36\n    var b = new BigInt();\n    b.digits[0] = radix;\n    var qr = RSAUtils.biDivideModulo(x, b);\n    var result = hexatrigesimalToChar[qr[1].digits[0]];\n\n    while (RSAUtils.biCompare(qr[0], bigZero) == 1) {\n      qr = RSAUtils.biDivideModulo(qr[0], b);\n      digit = qr[1].digits[0];\n      result += hexatrigesimalToChar[qr[1].digits[0]];\n    }\n\n    return (x.isNeg ? \"-\" : \"\") + RSAUtils.reverseStr(result);\n  };\n\n  RSAUtils.biToDecimal = function (x) {\n    var b = new BigInt();\n    b.digits[0] = 10;\n    var qr = RSAUtils.biDivideModulo(x, b);\n    var result = String(qr[1].digits[0]);\n\n    while (RSAUtils.biCompare(qr[0], bigZero) == 1) {\n      qr = RSAUtils.biDivideModulo(qr[0], b);\n      result += String(qr[1].digits[0]);\n    }\n\n    return (x.isNeg ? \"-\" : \"\") + RSAUtils.reverseStr(result);\n  };\n\n  var hexToChar = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n  RSAUtils.digitToHex = function (n) {\n    var mask = 0xf;\n    var result = \"\";\n\n    for (var i = 0; i < 4; ++i) {\n      result += hexToChar[n & mask];\n      n >>>= 4;\n    }\n\n    return RSAUtils.reverseStr(result);\n  };\n\n  RSAUtils.biToHex = function (x) {\n    var result = \"\";\n    var n = RSAUtils.biHighIndex(x);\n\n    for (var i = RSAUtils.biHighIndex(x); i > -1; --i) {\n      result += RSAUtils.digitToHex(x.digits[i]);\n    }\n\n    return result;\n  };\n\n  RSAUtils.charToHex = function (c) {\n    var ZERO = 48;\n    var NINE = ZERO + 9;\n    var littleA = 97;\n    var littleZ = littleA + 25;\n    var bigA = 65;\n    var bigZ = 65 + 25;\n    var result;\n\n    if (c >= ZERO && c <= NINE) {\n      result = c - ZERO;\n    } else if (c >= bigA && c <= bigZ) {\n      result = 10 + c - bigA;\n    } else if (c >= littleA && c <= littleZ) {\n      result = 10 + c - littleA;\n    } else {\n      result = 0;\n    }\n\n    return result;\n  };\n\n  RSAUtils.hexToDigit = function (s) {\n    var result = 0;\n    var sl = Math.min(s.length, 4);\n\n    for (var i = 0; i < sl; ++i) {\n      result <<= 4;\n      result |= RSAUtils.charToHex(s.charCodeAt(i));\n    }\n\n    return result;\n  };\n\n  RSAUtils.biFromHex = function (s) {\n    var result = new BigInt();\n    var sl = s.length;\n\n    for (var i = sl, j = 0; i > 0; i -= 4, ++j) {\n      result.digits[j] = RSAUtils.hexToDigit(s.substr(Math.max(i - 4, 0), Math.min(i, 4)));\n    }\n\n    return result;\n  };\n\n  RSAUtils.biFromString = function (s, radix) {\n    var isNeg = s.charAt(0) == '-';\n    var istop = isNeg ? 1 : 0;\n    var result = new BigInt();\n    var place = new BigInt();\n    place.digits[0] = 1; // radix^0\n\n    for (var i = s.length - 1; i >= istop; i--) {\n      var c = s.charCodeAt(i);\n      var digit = RSAUtils.charToHex(c);\n      var biDigit = RSAUtils.biMultiplyDigit(place, digit);\n      result = RSAUtils.biAdd(result, biDigit);\n      place = RSAUtils.biMultiplyDigit(place, radix);\n    }\n\n    result.isNeg = isNeg;\n    return result;\n  };\n\n  RSAUtils.biDump = function (b) {\n    return (b.isNeg ? \"-\" : \"\") + b.digits.join(\" \");\n  };\n\n  RSAUtils.biAdd = function (x, y) {\n    var result;\n\n    if (x.isNeg != y.isNeg) {\n      y.isNeg = !y.isNeg;\n      result = RSAUtils.biSubtract(x, y);\n      y.isNeg = !y.isNeg;\n    } else {\n      result = new BigInt();\n      var c = 0;\n      var n;\n\n      for (var i = 0; i < x.digits.length; ++i) {\n        n = x.digits[i] + y.digits[i] + c;\n        result.digits[i] = n % biRadix;\n        c = Number(n >= biRadix);\n      }\n\n      result.isNeg = x.isNeg;\n    }\n\n    return result;\n  };\n\n  RSAUtils.biSubtract = function (x, y) {\n    var result;\n\n    if (x.isNeg != y.isNeg) {\n      y.isNeg = !y.isNeg;\n      result = RSAUtils.biAdd(x, y);\n      y.isNeg = !y.isNeg;\n    } else {\n      result = new BigInt();\n      var n, c;\n      c = 0;\n\n      for (var i = 0; i < x.digits.length; ++i) {\n        n = x.digits[i] - y.digits[i] + c;\n        result.digits[i] = n % biRadix; // Stupid non-conforming modulus operation.\n\n        if (result.digits[i] < 0) result.digits[i] += biRadix;\n        c = 0 - Number(n < 0);\n      } // Fix up the negative sign, if any.\n\n\n      if (c == -1) {\n        c = 0;\n\n        for (var i = 0; i < x.digits.length; ++i) {\n          n = 0 - result.digits[i] + c;\n          result.digits[i] = n % biRadix; // Stupid non-conforming modulus operation.\n\n          if (result.digits[i] < 0) result.digits[i] += biRadix;\n          c = 0 - Number(n < 0);\n        } // Result is opposite sign of arguments.\n\n\n        result.isNeg = !x.isNeg;\n      } else {\n        // Result is same sign.\n        result.isNeg = x.isNeg;\n      }\n    }\n\n    return result;\n  };\n\n  RSAUtils.biHighIndex = function (x) {\n    var result = x.digits.length - 1;\n\n    while (result > 0 && x.digits[result] == 0) {\n      --result;\n    }\n\n    return result;\n  };\n\n  RSAUtils.biNumBits = function (x) {\n    var n = RSAUtils.biHighIndex(x);\n    var d = x.digits[n];\n    var m = (n + 1) * bitsPerDigit;\n    var result;\n\n    for (result = m; result > m - bitsPerDigit; --result) {\n      if ((d & 0x8000) != 0) break;\n      d <<= 1;\n    }\n\n    return result;\n  };\n\n  RSAUtils.biMultiply = function (x, y) {\n    var result = new BigInt();\n    var c;\n    var n = RSAUtils.biHighIndex(x);\n    var t = RSAUtils.biHighIndex(y);\n    var u, uv, k;\n\n    for (var i = 0; i <= t; ++i) {\n      c = 0;\n      k = i;\n\n      for (var j = 0; j <= n; ++j, ++k) {\n        uv = result.digits[k] + x.digits[j] * y.digits[i] + c;\n        result.digits[k] = uv & maxDigitVal;\n        c = uv >>> biRadixBits; //c = Math.floor(uv / biRadix);\n      }\n\n      result.digits[i + n + 1] = c;\n    } // Someone give me a logical xor, please.\n\n\n    result.isNeg = x.isNeg != y.isNeg;\n    return result;\n  };\n\n  RSAUtils.biMultiplyDigit = function (x, y) {\n    var n, c, uv;\n    var result = new BigInt();\n    n = RSAUtils.biHighIndex(x);\n    c = 0;\n\n    for (var j = 0; j <= n; ++j) {\n      uv = result.digits[j] + x.digits[j] * y + c;\n      result.digits[j] = uv & maxDigitVal;\n      c = uv >>> biRadixBits; //c = Math.floor(uv / biRadix);\n    }\n\n    result.digits[1 + n] = c;\n    return result;\n  };\n\n  RSAUtils.arrayCopy = function (src, srcStart, dest, destStart, n) {\n    var m = Math.min(srcStart + n, src.length);\n\n    for (var i = srcStart, j = destStart; i < m; ++i, ++j) {\n      dest[j] = src[i];\n    }\n  };\n\n  var highBitMasks = [0x0000, 0x8000, 0xC000, 0xE000, 0xF000, 0xF800, 0xFC00, 0xFE00, 0xFF00, 0xFF80, 0xFFC0, 0xFFE0, 0xFFF0, 0xFFF8, 0xFFFC, 0xFFFE, 0xFFFF];\n\n  RSAUtils.biShiftLeft = function (x, n) {\n    var digitCount = Math.floor(n / bitsPerDigit);\n    var result = new BigInt();\n    RSAUtils.arrayCopy(x.digits, 0, result.digits, digitCount, result.digits.length - digitCount);\n    var bits = n % bitsPerDigit;\n    var rightBits = bitsPerDigit - bits;\n\n    for (var i = result.digits.length - 1, i1 = i - 1; i > 0; --i, --i1) {\n      result.digits[i] = result.digits[i] << bits & maxDigitVal | (result.digits[i1] & highBitMasks[bits]) >>> rightBits;\n    }\n\n    result.digits[0] = result.digits[i] << bits & maxDigitVal;\n    result.isNeg = x.isNeg;\n    return result;\n  };\n\n  var lowBitMasks = [0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF];\n\n  RSAUtils.biShiftRight = function (x, n) {\n    var digitCount = Math.floor(n / bitsPerDigit);\n    var result = new BigInt();\n    RSAUtils.arrayCopy(x.digits, digitCount, result.digits, 0, x.digits.length - digitCount);\n    var bits = n % bitsPerDigit;\n    var leftBits = bitsPerDigit - bits;\n\n    for (var i = 0, i1 = i + 1; i < result.digits.length - 1; ++i, ++i1) {\n      result.digits[i] = result.digits[i] >>> bits | (result.digits[i1] & lowBitMasks[bits]) << leftBits;\n    }\n\n    result.digits[result.digits.length - 1] >>>= bits;\n    result.isNeg = x.isNeg;\n    return result;\n  };\n\n  RSAUtils.biMultiplyByRadixPower = function (x, n) {\n    var result = new BigInt();\n    RSAUtils.arrayCopy(x.digits, 0, result.digits, n, result.digits.length - n);\n    return result;\n  };\n\n  RSAUtils.biDivideByRadixPower = function (x, n) {\n    var result = new BigInt();\n    RSAUtils.arrayCopy(x.digits, n, result.digits, 0, result.digits.length - n);\n    return result;\n  };\n\n  RSAUtils.biModuloByRadixPower = function (x, n) {\n    var result = new BigInt();\n    RSAUtils.arrayCopy(x.digits, 0, result.digits, 0, n);\n    return result;\n  };\n\n  RSAUtils.biCompare = function (x, y) {\n    if (x.isNeg != y.isNeg) {\n      return 1 - 2 * Number(x.isNeg);\n    }\n\n    for (var i = x.digits.length - 1; i >= 0; --i) {\n      if (x.digits[i] != y.digits[i]) {\n        if (x.isNeg) {\n          return 1 - 2 * Number(x.digits[i] > y.digits[i]);\n        } else {\n          return 1 - 2 * Number(x.digits[i] < y.digits[i]);\n        }\n      }\n    }\n\n    return 0;\n  };\n\n  RSAUtils.biDivideModulo = function (x, y) {\n    var nb = RSAUtils.biNumBits(x);\n    var tb = RSAUtils.biNumBits(y);\n    var origYIsNeg = y.isNeg;\n    var q, r;\n\n    if (nb < tb) {\n      // |x| < |y|\n      if (x.isNeg) {\n        q = RSAUtils.biCopy(bigOne);\n        q.isNeg = !y.isNeg;\n        x.isNeg = false;\n        y.isNeg = false;\n        r = biSubtract(y, x); // Restore signs, 'cause they're references.\n\n        x.isNeg = true;\n        y.isNeg = origYIsNeg;\n      } else {\n        q = new BigInt();\n        r = RSAUtils.biCopy(x);\n      }\n\n      return [q, r];\n    }\n\n    q = new BigInt();\n    r = x; // Normalize Y.\n\n    var t = Math.ceil(tb / bitsPerDigit) - 1;\n    var lambda = 0;\n\n    while (y.digits[t] < biHalfRadix) {\n      y = RSAUtils.biShiftLeft(y, 1);\n      ++lambda;\n      ++tb;\n      t = Math.ceil(tb / bitsPerDigit) - 1;\n    } // Shift r over to keep the quotient constant. We'll shift the\n    // remainder back at the end.\n\n\n    r = RSAUtils.biShiftLeft(r, lambda);\n    nb += lambda; // Update the bit count for x.\n\n    var n = Math.ceil(nb / bitsPerDigit) - 1;\n    var b = RSAUtils.biMultiplyByRadixPower(y, n - t);\n\n    while (RSAUtils.biCompare(r, b) != -1) {\n      ++q.digits[n - t];\n      r = RSAUtils.biSubtract(r, b);\n    }\n\n    for (var i = n; i > t; --i) {\n      var ri = i >= r.digits.length ? 0 : r.digits[i];\n      var ri1 = i - 1 >= r.digits.length ? 0 : r.digits[i - 1];\n      var ri2 = i - 2 >= r.digits.length ? 0 : r.digits[i - 2];\n      var yt = t >= y.digits.length ? 0 : y.digits[t];\n      var yt1 = t - 1 >= y.digits.length ? 0 : y.digits[t - 1];\n\n      if (ri == yt) {\n        q.digits[i - t - 1] = maxDigitVal;\n      } else {\n        q.digits[i - t - 1] = Math.floor((ri * biRadix + ri1) / yt);\n      }\n\n      var c1 = q.digits[i - t - 1] * (yt * biRadix + yt1);\n      var c2 = ri * biRadixSquared + (ri1 * biRadix + ri2);\n\n      while (c1 > c2) {\n        --q.digits[i - t - 1];\n        c1 = q.digits[i - t - 1] * (yt * biRadix | yt1);\n        c2 = ri * biRadix * biRadix + (ri1 * biRadix + ri2);\n      }\n\n      b = RSAUtils.biMultiplyByRadixPower(y, i - t - 1);\n      r = RSAUtils.biSubtract(r, RSAUtils.biMultiplyDigit(b, q.digits[i - t - 1]));\n\n      if (r.isNeg) {\n        r = RSAUtils.biAdd(r, b);\n        --q.digits[i - t - 1];\n      }\n    }\n\n    r = RSAUtils.biShiftRight(r, lambda); // Fiddle with the signs and stuff to make sure that 0 <= r < y.\n\n    q.isNeg = x.isNeg != origYIsNeg;\n\n    if (x.isNeg) {\n      if (origYIsNeg) {\n        q = RSAUtils.biAdd(q, bigOne);\n      } else {\n        q = RSAUtils.biSubtract(q, bigOne);\n      }\n\n      y = RSAUtils.biShiftRight(y, lambda);\n      r = RSAUtils.biSubtract(y, r);\n    } // Check for the unbelievably stupid degenerate case of r == -0.\n\n\n    if (r.digits[0] == 0 && RSAUtils.biHighIndex(r) == 0) r.isNeg = false;\n    return [q, r];\n  };\n\n  RSAUtils.biDivide = function (x, y) {\n    return RSAUtils.biDivideModulo(x, y)[0];\n  };\n\n  RSAUtils.biModulo = function (x, y) {\n    return RSAUtils.biDivideModulo(x, y)[1];\n  };\n\n  RSAUtils.biMultiplyMod = function (x, y, m) {\n    return RSAUtils.biModulo(RSAUtils.biMultiply(x, y), m);\n  };\n\n  RSAUtils.biPow = function (x, y) {\n    var result = bigOne;\n    var a = x;\n\n    while (true) {\n      if ((y & 1) != 0) result = RSAUtils.biMultiply(result, a);\n      y >>= 1;\n      if (y == 0) break;\n      a = RSAUtils.biMultiply(a, a);\n    }\n\n    return result;\n  };\n\n  RSAUtils.biPowMod = function (x, y, m) {\n    var result = bigOne;\n    var a = x;\n    var k = y;\n\n    while (true) {\n      if ((k.digits[0] & 1) != 0) result = RSAUtils.biMultiplyMod(result, a, m);\n      k = RSAUtils.biShiftRight(k, 1);\n      if (k.digits[0] == 0 && RSAUtils.biHighIndex(k) == 0) break;\n      a = RSAUtils.biMultiplyMod(a, a, m);\n    }\n\n    return result;\n  };\n\n  $w.BarrettMu = function (m) {\n    this.modulus = RSAUtils.biCopy(m);\n    this.k = RSAUtils.biHighIndex(this.modulus) + 1;\n    var b2k = new BigInt();\n    b2k.digits[2 * this.k] = 1; // b2k = b^(2k)\n\n    this.mu = RSAUtils.biDivide(b2k, this.modulus);\n    this.bkplus1 = new BigInt();\n    this.bkplus1.digits[this.k + 1] = 1; // bkplus1 = b^(k+1)\n\n    this.modulo = BarrettMu_modulo;\n    this.multiplyMod = BarrettMu_multiplyMod;\n    this.powMod = BarrettMu_powMod;\n  };\n\n  function BarrettMu_modulo(x) {\n    var $dmath = RSAUtils;\n    var q1 = $dmath.biDivideByRadixPower(x, this.k - 1);\n    var q2 = $dmath.biMultiply(q1, this.mu);\n    var q3 = $dmath.biDivideByRadixPower(q2, this.k + 1);\n    var r1 = $dmath.biModuloByRadixPower(x, this.k + 1);\n    var r2term = $dmath.biMultiply(q3, this.modulus);\n    var r2 = $dmath.biModuloByRadixPower(r2term, this.k + 1);\n    var r = $dmath.biSubtract(r1, r2);\n\n    if (r.isNeg) {\n      r = $dmath.biAdd(r, this.bkplus1);\n    }\n\n    var rgtem = $dmath.biCompare(r, this.modulus) >= 0;\n\n    while (rgtem) {\n      r = $dmath.biSubtract(r, this.modulus);\n      rgtem = $dmath.biCompare(r, this.modulus) >= 0;\n    }\n\n    return r;\n  }\n\n  function BarrettMu_multiplyMod(x, y) {\n    /*\n    x = this.modulo(x);\n    y = this.modulo(y);\n    */\n    var xy = RSAUtils.biMultiply(x, y);\n    return this.modulo(xy);\n  }\n\n  function BarrettMu_powMod(x, y) {\n    var result = new BigInt();\n    result.digits[0] = 1;\n    var a = x;\n    var k = y;\n\n    while (true) {\n      if ((k.digits[0] & 1) != 0) result = this.multiplyMod(result, a);\n      k = RSAUtils.biShiftRight(k, 1);\n      if (k.digits[0] == 0 && RSAUtils.biHighIndex(k) == 0) break;\n      a = this.multiplyMod(a, a);\n    }\n\n    return result;\n  }\n\n  var RSAKeyPair = function RSAKeyPair(encryptionExponent, decryptionExponent, modulus) {\n    var $dmath = RSAUtils;\n    this.e = $dmath.biFromHex(encryptionExponent);\n    this.d = $dmath.biFromHex(decryptionExponent);\n    this.m = $dmath.biFromHex(modulus); // We can do two bytes per digit, so\n    // chunkSize = 2 * (number of digits in modulus - 1).\n    // Since biHighIndex returns the high index, not the number of digits, 1 has\n    // already been subtracted.\n\n    this.chunkSize = 2 * $dmath.biHighIndex(this.m);\n    this.radix = 16;\n    this.barrett = new $w.BarrettMu(this.m);\n  };\n\n  RSAUtils.getKeyPair = function (encryptionExponent, decryptionExponent, modulus) {\n    return new RSAKeyPair(encryptionExponent, decryptionExponent, modulus);\n  };\n\n  if (typeof $w.twoDigit === 'undefined') {\n    $w.twoDigit = function (n) {\n      return (n < 10 ? \"0\" : \"\") + String(n);\n    };\n  } // Altered by Rob Saunders (rob@robsaunders.net). New routine pads the\n  // string after it has been converted to an array. This fixes an\n  // incompatibility with Flash MX's ActionScript.\n\n\n  RSAUtils.encryptedString = function (key, s) {\n    var a = [];\n    var sl = s.length;\n    var i = 0;\n\n    while (i < sl) {\n      a[i] = s.charCodeAt(i);\n      i++;\n    }\n\n    while (a.length % key.chunkSize != 0) {\n      a[i++] = 0;\n    }\n\n    var al = a.length;\n    var result = \"\";\n    var j, k, block;\n\n    for (i = 0; i < al; i += key.chunkSize) {\n      block = new BigInt();\n      j = 0;\n\n      for (k = i; k < i + key.chunkSize; ++j) {\n        block.digits[j] = a[k++];\n        block.digits[j] += a[k++] << 8;\n      }\n\n      var crypt = key.barrett.powMod(block, key.e);\n      var text = key.radix == 16 ? RSAUtils.biToHex(crypt) : RSAUtils.biToString(crypt, key.radix);\n      result += text + \" \";\n    }\n\n    return result.substring(0, result.length - 1); // Remove last space.\n  };\n\n  RSAUtils.decryptedString = function (key, s) {\n    var blocks = s.split(\" \");\n    var result = \"\";\n    var i, j, block;\n\n    for (i = 0; i < blocks.length; ++i) {\n      var bi;\n\n      if (key.radix == 16) {\n        bi = RSAUtils.biFromHex(blocks[i]);\n      } else {\n        bi = RSAUtils.biFromString(blocks[i], key.radix);\n      }\n\n      block = key.barrett.powMod(bi, key.d);\n\n      for (j = 0; j <= RSAUtils.biHighIndex(block); ++j) {\n        result += String.fromCharCode(block.digits[j] & 255, block.digits[j] >> 8);\n      }\n    } // Remove trailing null, if any.\n\n\n    if (result.charCodeAt(result.length - 1) == 0) {\n      result = result.substring(0, result.length - 1);\n    }\n\n    return result;\n  };\n\n  RSAUtils.setMaxDigits(130);\n  return RSAUtils;\n}(window);\n\nexport { RSAUtils };",null]}